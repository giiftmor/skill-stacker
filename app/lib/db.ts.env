// app/lib/db.ts
import sqlite3 from 'sqlite3';
import { open, Database } from 'sqlite';
import path from 'path';

let db: Database | null = null;

// Initialize database connection
export async function initDb() {
  if (db) return db;

  db = await open({
    filename: path.join(process.cwd(), 'cvbuilder.db'),
    driver: sqlite3.Database
  });

  // Create tables if they don't exist
  await db.exec(`
    CREATE TABLE IF NOT EXISTS cvs (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      full_name TEXT NOT NULL,
      title TEXT,
      phone TEXT,
      email TEXT,
      location TEXT,
      profile TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS skills (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      cv_id INTEGER NOT NULL,
      skill TEXT NOT NULL,
      FOREIGN KEY (cv_id) REFERENCES cvs(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS experiences (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      cv_id INTEGER NOT NULL,
      company TEXT,
      role TEXT,
      period TEXT,
      details TEXT,
      FOREIGN KEY (cv_id) REFERENCES cvs(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS education (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      cv_id INTEGER NOT NULL,
      institution TEXT,
      qualification TEXT,
      period TEXT,
      FOREIGN KEY (cv_id) REFERENCES cvs(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS references (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      cv_id INTEGER NOT NULL,
      reference TEXT NOT NULL,
      FOREIGN KEY (cv_id) REFERENCES cvs(id) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_cv_id_skills ON skills(cv_id);
    CREATE INDEX IF NOT EXISTS idx_cv_id_experiences ON experiences(cv_id);
    CREATE INDEX IF NOT EXISTS idx_cv_id_education ON education(cv_id);
    CREATE INDEX IF NOT EXISTS idx_cv_id_references ON references(cv_id);
  `);

  return db;
}

// Save CV data
export async function saveCV(data: {
  personal: {
    fullName: string;
    title: string;
    phone: string;
    email: string;
    location: string;
  };
  profile: string;
  skills: string[];
  experiences: Array<{
    company: string;
    role: string;
    period: string;
    details: string;
  }>;
  education: Array<{
    institution: string;
    qualification: string;
    period: string;
  }>;
  references: string[];
}) {
  const database = await initDb();

  try {
    await database.run('BEGIN TRANSACTION');

    // Insert CV personal information
    const result = await database.run(
      `INSERT INTO cvs (full_name, title, phone, email, location, profile)
       VALUES (?, ?, ?, ?, ?, ?)`,
      [
        data.personal.fullName,
        data.personal.title,
        data.personal.phone,
        data.personal.email,
        data.personal.location,
        data.profile
      ]
    );

    const cvId = result.lastID;

    // Insert skills
    for (const skill of data.skills.filter(Boolean)) {
      await database.run(
        'INSERT INTO skills (cv_id, skill) VALUES (?, ?)',
        [cvId, skill]
      );
    }

    // Insert experiences
    for (const exp of data.experiences.filter(e => e.company || e.role)) {
      await database.run(
        `INSERT INTO experiences (cv_id, company, role, period, details)
         VALUES (?, ?, ?, ?, ?)`,
        [cvId, exp.company, exp.role, exp.period, exp.details]
      );
    }

    // Insert education
    for (const edu of data.education.filter(e => e.institution || e.qualification)) {
      await database.run(
        `INSERT INTO education (cv_id, institution, qualification, period)
         VALUES (?, ?, ?, ?)`,
        [cvId, edu.institution, edu.qualification, edu.period]
      );
    }

    // Insert references
    for (const ref of data.references.filter(Boolean)) {
      await database.run(
        'INSERT INTO references (cv_id, reference) VALUES (?, ?)',
        [cvId, ref]
      );
    }

    await database.run('COMMIT');
    return { success: true, cvId };
  } catch (error) {
    await database.run('ROLLBACK');
    console.error('Error saving CV:', error);
    throw error;
  }
}

// Update existing CV
export async function updateCV(cvId: number, data: any) {
  const database = await initDb();

  try {
    await database.run('BEGIN TRANSACTION');

    // Update CV personal information
    await database.run(
      `UPDATE cvs 
       SET full_name = ?, title = ?, phone = ?, email = ?, location = ?, 
           profile = ?, updated_at = CURRENT_TIMESTAMP
       WHERE id = ?`,
      [
        data.personal.fullName,
        data.personal.title,
        data.personal.phone,
        data.personal.email,
        data.personal.location,
        data.profile,
        cvId
      ]
    );

    // Delete existing related records
    await database.run('DELETE FROM skills WHERE cv_id = ?', [cvId]);
    await database.run('DELETE FROM experiences WHERE cv_id = ?', [cvId]);
    await database.run('DELETE FROM education WHERE cv_id = ?', [cvId]);
    await database.run('DELETE FROM references WHERE cv_id = ?', [cvId]);

    // Re-insert new data (same as saveCV)
    for (const skill of data.skills.filter(Boolean)) {
      await database.run(
        'INSERT INTO skills (cv_id, skill) VALUES (?, ?)',
        [cvId, skill]
      );
    }

    for (const exp of data.experiences.filter((e: any) => e.company || e.role)) {
      await database.run(
        `INSERT INTO experiences (cv_id, company, role, period, details)
         VALUES (?, ?, ?, ?, ?)`,
        [cvId, exp.company, exp.role, exp.period, exp.details]
      );
    }

    for (const edu of data.education.filter((e: any) => e.institution || e.qualification)) {
      await database.run(
        `INSERT INTO education (cv_id, institution, qualification, period)
         VALUES (?, ?, ?, ?)`,
        [cvId, edu.institution, edu.qualification, edu.period]
      );
    }

    for (const ref of data.references.filter(Boolean)) {
      await database.run(
        'INSERT INTO references (cv_id, reference) VALUES (?, ?)',
        [cvId, ref]
      );
    }

    await database.run('COMMIT');
    return { success: true, cvId };
  } catch (error) {
    await database.run('ROLLBACK');
    console.error('Error updating CV:', error);
    throw error;
  }
}

// Get CV by ID
export async function getCV(cvId: number) {
  const database = await initDb();

  const cv = await database.get('SELECT * FROM cvs WHERE id = ?', [cvId]);
  if (!cv) return null;

  const skills = await database.all(
    'SELECT skill FROM skills WHERE cv_id = ? ORDER BY id',
    [cvId]
  );

  const experiences = await database.all(
    'SELECT company, role, period, details FROM experiences WHERE cv_id = ? ORDER BY id',
    [cvId]
  );

  const education = await database.all(
    'SELECT institution, qualification, period FROM education WHERE cv_id = ? ORDER BY id',
    [cvId]
  );

  const references = await database.all(
    'SELECT reference FROM references WHERE cv_id = ? ORDER BY id',
    [cvId]
  );

  return {
    personal: {
      fullName: cv.full_name,
      title: cv.title,
      phone: cv.phone,
      email: cv.email,
      location: cv.location
    },
    profile: cv.profile,
    skills: skills.map(s => s.skill),
    experiences,
    education,
    references: references.map(r => r.reference),
    createdAt: cv.created_at,
    updatedAt: cv.updated_at
  };
}

// Get all CVs (summary list)
export async function getAllCVs() {
  const database = await initDb();

  const cvs = await database.all(
    'SELECT id, full_name, title, email, created_at, updated_at FROM cvs ORDER BY updated_at DESC'
  );

  return cvs.map(cv => ({
    id: cv.id,
    fullName: cv.full_name,
    title: cv.title,
    email: cv.email,
    createdAt: cv.created_at,
    updatedAt: cv.updated_at
  }));
}

// Delete CV
export async function deleteCV(cvId: number) {
  const database = await initDb();

  try {
    await database.run('DELETE FROM cvs WHERE id = ?', [cvId]);
    return { success: true };
  } catch (error) {
    console.error('Error deleting CV:', error);
    throw error;
  }
}